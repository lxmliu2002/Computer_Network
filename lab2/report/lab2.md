# <center>**计算机网络实验报告**</center>

## <center>**Lab2 配置Web服务器，编写简单页面，分析交互过程**</center>

## <center> **网络空间安全学院 信息安全专业**</center>

## <center> **2112492 刘修铭 1063**</center>

https://github.com/lxmliu2002/Computer_Networking

# 一、Web服务器配置

本项目借助Node.js，使用parcel-bundler打包配置Web服务器。

使用命令行，输入`npm start`指令，可以看到项目得以成功运行。

<img src="./pic/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231011134946.png" style="zoom: 33%;" />

打开浏览器，输入`http://127.0.0.1:8080`得到如下界面。

<img src="./pic/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231011134905.png" style="zoom: 33%;" />



# 二、简单页面编写

在给定框架的基础上，进行内容删改，使之成为一个自己的个人主页，包括专业、学号、姓名、LOGO、自我介绍音频信息等内容。为避免报告冗长，已将源代码附后。

<img src="./pic/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231011134905.png" style="zoom: 33%;" />



# 三、交互过程分析

## （一）准备工作

* 下载安装Wireshark抓包软件
* 启动软件，选择`Adapter for loopback traffic capture`接口
* 按照前面创建的设定设置过滤器`(ip.dst == 127.0.0.1 or ip.src == 127.0.0.1) and (tcp.srcport == 8080 or tcp.dstport == 8080)`

## （二）数据分析

按照上面设定，运行一段时间，得到如下的抓包结果。

<img src="./pic/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231011200825.png" style="zoom: 20%;" />

接下来将对整个交互过程进行分析。

### 1. TCP三次握手建立连接

TCP使用三次握手建立连接

<img src="./pic/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231011204419.jpg" style="zoom: 25%;" />

在wireshark中可以看到三次握手的过程。

<img src="./pic/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231011204613.png" style="zoom:80%;" />

* 第一次握手：建立连接时，客户端发送SYN到服务器，并进入SYN_SENT状态，等待服务器确认。

  <img src="./pic/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231011205124.png" style="zoom: 20%;" />

  * TCP客户端向服务器端发送连接请求报文段，即**客户端**发送SYN到服务器，并进入SYN_SENT状态，等待**服务器端**确认
  * 第一次握手成功说明客户端的数据可以被服务端收到，说明客户端的发功能可用，说明服务端的收功能可用。但客户端自己不知道数据是否被接收
    * Source Port：63691
    * Destination Port：8080
    * SYN ：标志位，表示请求建立连接
    * Seq = 0 ：初始建立连接值为0，数据包的相对序列号从0开始，表示当前还没有发送数据
    * Ack =0：初始建立连接值为0，已经收到包的数量，表示当前没有接收到数据
    * WIN = 65535来自Window size: 65535
    * MSS = 65495来自 Maximum segment size: 65495byte ，最长报文段，TCP包所能携带的最大数据量，不包含TCP头和Option。一般为MTU值减去IPv4头部(至少20字节)和TCP头部(至少20字节)得到
    * WS = 256 来自windows scale : 8 (multiply by 256)： 窗口扩张，放在TCP头之外的Option，向对方声明一个shift count，作为2的指数，再乘以TCP定义的接收窗口，得到真正的TCP窗口
  
* 第二次握手：服务器收到请求后，回送SYN+ACK信令到客户端，此时服务器进入SYN_RECV状态。

  <img src="./pic/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231011205643.png" style="zoom: 20%;" />

  * 第二次握手时，**服务器端**为该TCP连接分配缓存和变量

  * **服务器端**收到数据包后由标志位 SYN=1 得知**客户端**请求建立连接，然后便发送确认报文段（SYN+ACK信令）到**客户端**，接着**服务器**进入SYN_RECV状态

  * 第二次握手成功说明服务端的数据可以被客户端收到，说明服务端的发功能可用，说明客户端的收功能可用。同时客户端知道自己的数据已经正确到达服务端，自己的发功能正常。但是服务端自己不知道数据是否被接收
    * Source Port：8080
    * Destination Port：63691
    * Seq = 0 ：初始建立值为0，表示当前还没有发送数据
    * Ack = 1 : 表示当前端成功接收的数据位数，虽然客户端没有发送任何有效数据，确认号还是被加1，因为包含SYN或FIN标志位


* 第三次握手：客户端收到SYN+ACK包，向服务器发送确认ACK包，客户端进入ESTABLISHED状态，服务器收到请求后也进入ESTABLISHED状态，完成三次握手，此时TCP连接成功，客户端与服务器开始传送数据。

  <img src="./pic/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231011210943.png" style="zoom:20%;" />

  * 第三次握手时，**客户端**为该TCP连接分配缓存和变量
  * **客户端**收到**服务器端**确认后，检查 ack 是否为 x+1，ACK 是否为 1，如果正确则再发送一个确认报文段给**服务器**，同时**客户端**进入ESTABLISHED状态，**服务器**收到请求后也进入ESTABLISHED状态，三次握手完成
  * 第三次握手成功说明服务端知道自己的数据已经正确到达客户端端，自己的发功能正常。至此服务成功建立
    * Source Port：63691
    * Destination Port：8080
    * Seq = 1 ：表示当前已经发送1个数据
      
    * Ack = 1 : 表示当前端成功接收的数据位数
      
    * ACK ：标志位，表示已经收到记录
  

### 2. 发送与收取数据

客户端和服务端建立连接后，开始传输数据。

<img src="./pic/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231011221420.png" style="zoom: 33%;" />

* HTTP请求由三部分组成：请求行，消息报文，请求正文；格式为：Method　Request－URI　HTTP－Version　CRLF；Method表示请求方法；Request-URI是一个统一资源标识符；HTTP-Version表示请求的HTTP协议版本；CRLF表示回车和换行。
* HTTP响应由三部分组成：状态行，消息报头，响应正文；格式为：HTTP-Version Status-Code Reason-Phrase CRLF；HTTP-Version表示服务器HTTP协议的版本，Status-Code表示服务器发回的响应状态代码，Reason-Phrase表示状态代码的文本描述。

  * 浏览器向域名发出HTTP请求；
  * 通过TCP- IP（DNS）->MAC（ARP）->网关->目的主机；
  * 目的主机收到数据帧，通过IP->TCP->HTTP，HTTP协议单元会回应HTTP协议格式封装好的HTML形式数据（HTTP响应）；
  * 该HTML数据通过TCP->IP（DNS）->MAC（ARP）->网关->我的主机；
  * 主机收到数据帧，通过IP->TCP->HTTP->浏览器，浏览器以网页形式显示HTML内容。

#### （1）HTTP请求报文

一个HTTP请求报文由请求行（request line）、请求头部（request header）、空行和请求数据4个部分构成。

<img src="./pic/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231011221817.png" style="zoom:50%;" />

* **请求行**，给出了请求类型，URI给出请求的资源位置(/)。HTTP中的请求类型包

  * 请求行数据格式由三个部分组成：请求方法、URI、HTTP协议版本，他们之间用空格分隔。

* **请求头**，主要是用于说明请求源、连接类型、以及一些Cookie信息等

  * 请求头部紧跟着请求行，该部分主要是用于描述请求正文。

* **请求正文**，一般用于存放POST请求类型的请求正文

#### （2）HTTP响应报文

HTTP响应报文由状态行（HTTP版本、状态码（数字和原因短语））、响应头部、空行和响应体4个部分构成。

<img src="./pic/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231011223243.png" style="zoom:50%;" />

* **状态行**，主要给出响应HTTP协议的版本号、响应返回状态码、响应描述，同样是单行显示。

    * 1XX 请求正在处理
    * 2XX 请求成功
    * 302 Found 资源的URI已临时定位到其他位置，客户端不会更新URI。
    * 303 See Other 资源的URI已更新，明确表示客户端要使用GET方法获取资源。
    * 304 Not Modified 当客户端附带条件请求访问资源时资源已找到但未符合条件请求。
    * 400 请求报文中存在语法错误
    * 403 对请求资源的访问被服务器拒绝 
    * 404 请求资源不存在
    * 405 请求的方式不支持
    * 5XX 服务器错误
    * 503 服务器暂时处于超负载状态或正在进行停机维护

* **响应头部**，与响应头部类似，主要是返回一些服务器的基本信息，以及一些Cookie值等
* **响应体**，为请求需要得到的具体数据，可以为任何类型数据，一般网页浏览返回的为html文件内容

#### （3）HTTP请求与响应

在本次实验数据中，可以看到在三次握手建立连接与四次挥手关闭连接中间有四次HTTP请求与响应。

<img src="./pic/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231011225435.png" style="zoom: 25%;" />

下面以第一轮请求与响应为例进行分析。

##### 客户端向服务器端发送请求

<img src="./pic/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231011231312.png" style="zoom: 20%;" />

* **请求行**

  * 请求方式：GET
  * 请求URI：/
  * 协议版本：HTTP/1.1

* **请求头**

  * Host

  * Connection

  * User-Agent

    ……

##### 服务器端回复ACK表示收到请求

<img src="./pic/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231011232141.png" style="zoom:20%;" />

##### 服务器端向客户端发送响应报文

<img src="./pic/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231011231344.png" style="zoom: 20%;" />

* 状态行
  * 协议版本：HTTP/1.1
  * 状态码：200，表示OK
* 响应头部
  * Cache-Control
  * Last-Modified
  * Connection
  * …
* 响应体
  * index.html的内容


##### 客户端回复ACK表示收到请求

<img src="./pic/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231011233045.png" style="zoom:20%;" />

### 3. TCP四次挥手关闭连接（此处以服务器端主动关闭连接为例）

TCP使用四次挥手关闭连接，客户端和服务端分别释放连接

<img src="./pic/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231011224233.jpg" style="zoom: 25%;" />

在wireshark中可以看到四次挥手的过程。

![](./pic/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231011224112.png)

* 第一次挥手：主动关闭方发送一个FIN并进入FIN_WAIT1状态

  <img src="./pic/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231011224751.png" style="zoom: 20%;" />

  * **服务器端**向**客户端**发送主动关闭连接报文

  * **服务器端**进入FIN_WAIT1状态，等待**客户端**回复
    * Source Port：8080
    * Destination Port：63772
    * Seq = 53700
    * Ack = 3011
    * ACK、FIN ：标志位
  
* 第二次挥手：被动关闭方接收到主动关闭方发送的FIN并发送ACK，此时被动关闭方进入CLOSE_WAIT状态；主动关闭方收到被动关闭方的ACK后，进入FIN_WAIT2状态

  <img src="./pic/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231011224811.png" style="zoom: 20%;" />

  * **客户端**接收报文，并回复确认报文

  * **客户端**进入CLOSE_WAIT状态；**服务器端**收到**客户端**的确认报文后进入FIN_WAIT2状态
    * Source Port：63772
    * Destination Port：8080
    * Seq = 3011
    * Ack = 53701
    * ACK ：标志位
  
* 第三次挥手：被动关闭方发送一个FIN并进入LAST_ACK状态

  <img src="./pic/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231011224832.png" style="zoom: 20%;" />

  * **客户端**在确认数据传输完毕后向**服务器端**发送结束报文
  * **客户端**进入LAST_ACK状态，等待**服务器端**最后确认
    * Source Port：8080
    * Destination Port：63772
    * Seq = 3011
    * Ack = 53701
    * ACK、FIN ：标志位
  
* 第四次挥手：主动关闭方收到被动关闭方发送的FIN并发送ACK，此时主动关闭方进入TIME_WAIT状态，经过2MSL时间后关闭连接；被动关闭方收到主动关闭方的ACK后，关闭连接

  <img src="./pic/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231011224851.png" style="zoom: 20%;" />

  * **服务器端**回复确认报文，然后进入TIME_WAIT状态，经过2MSL时间后关闭连接（MSL是数据分节在网络中存活的最长时间）
  * **客户端**接收到确认报文后关闭连接
    * Source Port：63772
    * Destination Port：8080
    * Seq = 53701
    * Ack = 3012
    * ACK ：标志位
  

比较主流的文章都说关闭TCP会话是四次挥手，但是实际上为了提高效率通常合并第二、三次的挥手，即三次挥手。



# 四、问题思考

1. 为何是三次握手而不是两次或四次握手？

   失效的连接请求是指，若客户端向服务端发送的连接请求丢失，客户端等待应答超时后就会再次发送连接请求，此时，上一个连接请求就是失效的。三次握手可以防止失效的连接请求报文段被服务端接收从而产生错误。

   若建立连接只需两次握手，客户端并没有太大的变化，仍然需要获得服务端的应答后才进入ESTABLISHED状态，而服务端在收到连接请求后就进入ESTABLISHED状态。此时如果网络拥塞，客户端发送的连接请求迟迟到不了服务端，客户端便超时重发请求，如果服务端正确接收并确认应答，双方便开始通信，通信结束后释放连接。此时，如果那个失效的连接请求抵达了服务端，由于只有两次握手，服务端收到请求就会进入ESTABLISHED状态，等待发送数据或主动发送数据。但此时的客户端早已进入CLOSED状态，服务端将会一直等待下去，这样浪费服务端连接资源。

   但是是可以四次甚至更多次，但选择三次的原因是因为三次握手足以，无须过多浪费资源。

2. 为何是四次挥手而不是两次或三次挥手？（以客户端主动申请断开连接为例）

   第一次挥手表示客户端发送了一个FIN的包，表示客户端已发送数据完毕，但是服务端这个时候可能还有数据没有发送完成，先发送给客户端一个ACK的包，等待自己的数据发送完成才能向客户端发送一个FIN的包，表示自己的数据也已发送完成。这样中间就必须为两次来发送ACK和FIN。

3. 304状态码

   在抓包时有时会遇到304状态码，该状态码的含义是目前请求的信息与之前请求的内容相比没有改动，此时客户端从缓存读取即可，无须由服务器端再发送。

4. keep-alive连接状态是什么？

   在get请求的请求头部分有个connection字段，该字段定义了其连接状态。其中，keep-alive意图在于短时间内连接复用，希望可以短时间内在同一个连接上进行多次请求/响应，避免每次通信建立连接的繁琐与资源浪费。
